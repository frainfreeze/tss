<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>tss: tss - Tom&#39;s Simple Shell</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tss
   </div>
   <div id="projectbrief">Simple shell implementation in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">tss - Tom's Simple Shell </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is learning project released in public domain. Comments and improvement suggestions are more than welcome, leave them <a href="https://github.com/frainfreeze/tss/issues">here</a>.</p>
<p>For the project I used <code>g++</code>, <code>make</code> and <code>doxygen</code>. To get those run <code>sudo apt-get install build-essential doxygen</code> on apt based systems. To build and start the shell run <code>./build-run.sh</code>, to build shell and docs run <code>make</code>, to clean everything run <code>make clean clean-docs</code>. To build documentation run <code>make docs</code>, you can find output in the docs folder or <a href="https://frainfreeze.github.io/tss/">here</a>.</p>
<h2>Shell in a nutshell</h2>
<p>A shell or command-line interpreter is a user interface for access to an operating system's services. In general, operating system shells use either a command-line interface (CLI) or graphical user interface (GUI), depending on a computer's role and particular operation. It is named a shell because it is the outermost layer around the operating system kernel.</p>
<blockquote class="doxtable">
<p>Although most users think of the shell as an interactive command interpreter, it is really a programming language in which each statement runs a command. Because it must satisfy both the interactive and programming aspects of command execution, it is a strange language, shaped as much by history as by design. — Brian Kernighan &amp; Rob Pike </p>
</blockquote>
<p>In it's essence shell is a Read–Eval–Print Loop (REPL), a simple, interactive computer programming environment that takes single user inputs (i.e. single expressions), evaluates them, and returns the result to the user.</p>
<p>Typical shell workflow is as follows:</p><ul>
<li>Startup: read and execute configuration files</li>
<li>Wait for user input and interpret (read commands from stdin (interactive/file) and execute them)<ul>
<li>Parsing</li>
<li>Expansion</li>
<li>Execution</li>
</ul>
</li>
<li>Terminate: executes any shutdown commands, free up any memory, and terminate</li>
</ul>
<h2>Startup</h2>
<p><code>Compare the output of echo $HOME in your shell to your regular shell. Your regular shell treats tokens beginning with $ specially: it looks them up by name in the environment, and substitutes them in the command. The</code>getenv<code>function looks up a variable in the environment. This can be handled during or after parsing a command.</code></p>
<h2>System calls</h2>
<p>The way our programs talk to the kernel is through system calls. These are operations we can tell the kernel to do on our behalf. Examples include:</p><ul>
<li>opening files (<code>open</code>)</li>
<li>reading and writing to them (<code>read</code>, <code>write</code>)</li>
<li>sending and receiving data over the network. (<code>sendto</code>, <code>recvfrom</code>)</li>
<li>starting programs (<code>execve</code>)</li>
<li>process creating a copy of itself (<code>fork</code>)</li>
</ul>
<p>In fact, more or less everything that involves our programs interacting with the ‘real world’ involves system calls.</p>
<p>Shell is parent process so it utilizes system call <code>fork</code>, this helps us to isolate commands which is important for fault tolerance. We dont want erroneous command to crash whole shell. The <code>fork</code> creates a new process that is a clone of the existing one, right down to the point in the program that's executing. We can then call exec in the newly created child process, leaving our shell's process around for future interaction.</p>
<p>The return value of fork tells us if we're in the child or the parent: it returns 0 for the child, and the id of the new process in the parent.</p>
<p>To wait for the child process to finish we can use <code>wait</code> system call.</p>
<h2>Builtins</h2>
<p>Every process has its own its own memory and extra metadata that the kernel manages, but that the process can't change directly. Process can use system calls to change user id (<code>setuid</code>), group id (<code>setgid</code>), priority (<code>setpriority</code>), working directory (<code>chdir</code>).</p>
<p>If you were to call change directory command it would invoke <code>chdir</code> internally, change its working dir and return to the parent process - however parents process working dir would stay unchanged, therefore shell has to have builting <code>cd</code> command that calls <code>chdir</code> system call on shell process itself. The handling of cd is then built in to our shell — it's a builtin.</p>
<p>In bash, <code>export</code> lets us change an environment variable's value in the shell itself. As with <code>cd</code>, because a child cannot modify its parent's environment, export must be a builtin.</p>
<p>See manpages on bash builtins <a href="https://linux.die.net/man/1/builtins">man builtins</a> for more.</p>
<h2>Pipeline</h2>
<p>In Unix-like computer operating systems, a pipeline is a sequence of processes chained together by their standard streams, so that the output of each process (stdout) feeds directly as input (stdin) to the next one.</p>
<p>Pipes are unidirectional; data flows through the pipeline from left to right.</p>
<div class="fragment"><div class="line">process1 | process2 | process3</div></div><!-- fragment --><p>The <code>pipe()</code> system call asks the operating system to construct a new anonymous pipe object. This results in two new, opened file descriptors in the process: the read-only end of the pipe, and the write-only end. The pipe ends appear to be normal, anonymous file descriptors, except that they have no ability to seek.</p>
<p>To avoid deadlock and exploit parallelism, the Unix process with one or more new pipes will then, generally, call <code>fork()</code> to create new processes. Each process will then close the end(s) of the pipe that it will not be using before producing or consuming any data. Alternatively, a process might create a new thread and use the pipe to communicate between them.</p>
<p>Named pipes may also be created using <code>mkfifo()</code> or <code>mknod()</code> and then presented as the input or output file to programs as they are invoked. They allow multi-path pipes to be created, and are especially effective when combined with standard error redirection, or with tee.</p>
<p>In most Unix-like systems, all processes of a pipeline are started at the same time, with their streams appropriately connected, and managed by the scheduler together with all other processes running on the machine. An important aspect of this, setting Unix pipes apart from other pipe implementations, is the concept of buffering: for example a sending program may produce 5000 bytes per second, and a receiving program may only be able to accept 100 bytes per second, but no data is lost. Instead, the output of the sending program is held in the buffer. When the receiving program is ready to read data, then next program in the pipeline reads from the buffer. In Linux, the size of the buffer is 65536 bytes (64KiB).</p>
<p><a href="https://github.com/kamalmarhubi/shell-workshop#6-pipelines">https://github.com/kamalmarhubi/shell-workshop#6-pipelines</a></p><ul>
<li>IO redirection to/from files: <a href="https://github.com/kamalmarhubi/shell-workshop#2-io-redirection-tofrom-files">https://github.com/kamalmarhubi/shell-workshop#2-io-redirection-tofrom-files</a></li>
</ul>
<h2>Terminate</h2>
<p><code>Compare what happens when you hit ^C (control-C) between your shell and your regular shell. ^C sends a signal to your process, in this case</code>SIGINT`. Signals interrupt the normal execution of your program. By default, this aborts the process. To prevent that, we can register a signal handler function to be called when <code>SIGINT</code> is received, or decide to ignore it.`</p>
<h2>Todo:</h2>
<h3>Globbing</h3>
<p>Compare the output of wc -c * between your shell and your regular shell. Expanding the wildcard * is done by the shell before passing arguments to the child. The glob function in the &lt;glob.h&gt; standard header will be useful.</p>
<h3>Running a command in the background</h3>
<p>In your regular shell, if you end a command with &amp;, it runs in the background. The command will run, but the shell will not block while it does. Ie, it does not wait on the child process.</p>
<h2>Refs:</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Shell_(computing)">https://en.wikipedia.org/wiki/Shell_(computing)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bourne_shell">https://en.wikipedia.org/wiki/Bourne_shell</a></li>
<li><a href="https://linux.die.net/man/1/bash">https://linux.die.net/man/1/bash</a></li>
<li><a href="http://man7.org/linux/man-pages/dir_section_3.html">http://man7.org/linux/man-pages/dir_section_3.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">https://en.wikipedia.org/wiki/Pipeline_(Unix)</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
